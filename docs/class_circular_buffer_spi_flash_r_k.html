<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CircularBufferSpiFlashRK: CircularBufferSpiFlashRK Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CircularBufferSpiFlashRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">CircularBufferSpiFlashRK Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_data_buffer.html">DataBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold a copy of data, either by pointer and length or a c-string.  <a href="class_circular_buffer_spi_flash_r_k_1_1_data_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_read_info.html">ReadInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used by readData and markAsRead.  <a href="class_circular_buffer_spi_flash_r_k_1_1_read_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_record_common.html">RecordCommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data stored in flash for each record in the sector.  <a href="struct_circular_buffer_spi_flash_r_k_1_1_record_common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a sector, stored in RAM.  <a href="class_circular_buffer_spi_flash_r_k_1_1_sector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_sector_common.html">SectorCommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data stored after the magic bytes in flash.  <a href="struct_circular_buffer_spi_flash_r_k_1_1_sector_common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_sector_header.html">SectorHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure store at the beginning of each sector.  <a href="struct_circular_buffer_spi_flash_r_k_1_1_sector_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_usage_stats.html">UsageStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for various stats about the circular buffer usage.  <a href="class_circular_buffer_spi_flash_r_k_1_1_usage_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2d47fda1b8d9d0542ae45bcfa9c5d894" id="r_a2d47fda1b8d9d0542ae45bcfa9c5d894"><td class="memItemLeft" align="right" valign="top"><a id="a2d47fda1b8d9d0542ae45bcfa9c5d894" name="a2d47fda1b8d9d0542ae45bcfa9c5d894"></a>
struct <a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_record_common.html">CircularBufferSpiFlashRK::RecordCommon</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((__packed__))</td></tr>
<tr class="separator:a2d47fda1b8d9d0542ae45bcfa9c5d894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda19780f555c2699e929a421d839eef" id="r_abda19780f555c2699e929a421d839eef"><td class="memItemLeft" align="right" valign="top"><a id="abda19780f555c2699e929a421d839eef" name="abda19780f555c2699e929a421d839eef"></a>
struct <a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_sector_common.html">CircularBufferSpiFlashRK::SectorCommon</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((__packed__))</td></tr>
<tr class="separator:abda19780f555c2699e929a421d839eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b1e110ba5781153b85bdaca6025ba2" id="r_ad2b1e110ba5781153b85bdaca6025ba2"><td class="memItemLeft" align="right" valign="top"><a id="ad2b1e110ba5781153b85bdaca6025ba2" name="ad2b1e110ba5781153b85bdaca6025ba2"></a>
struct <a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_sector_header.html">CircularBufferSpiFlashRK::SectorHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((__packed__))</td></tr>
<tr class="separator:ad2b1e110ba5781153b85bdaca6025ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8247a646cef67d55a0b61b5dd6533ae" id="r_af8247a646cef67d55a0b61b5dd6533ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8247a646cef67d55a0b61b5dd6533ae">CircularBufferSpiFlashRK</a> (SpiFlash *<a class="el" href="#a578b17b5feeb99c1ba0378e8726089b0">spiFlash</a>, size_t <a class="el" href="#a09e0d4304539dc46c9ae8cc111a32388">addrStart</a>, size_t <a class="el" href="#abf699ab2202f8c1b93f3a806e6f6bd2a">addrEnd</a>)</td></tr>
<tr class="memdesc:af8247a646cef67d55a0b61b5dd6533ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new circular buffer object. This is typically done as a global variable.  <br /></td></tr>
<tr class="separator:af8247a646cef67d55a0b61b5dd6533ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdb38297a29247c2d93421cfdac69f0" id="r_aacdb38297a29247c2d93421cfdac69f0"><td class="memItemLeft" align="right" valign="top"><a id="aacdb38297a29247c2d93421cfdac69f0" name="aacdb38297a29247c2d93421cfdac69f0"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~CircularBufferSpiFlashRK</b> ()</td></tr>
<tr class="memdesc:aacdb38297a29247c2d93421cfdac69f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the object. <br /></td></tr>
<tr class="separator:aacdb38297a29247c2d93421cfdac69f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adb742373527d0dc3c1255357a863e5" id="r_a8adb742373527d0dc3c1255357a863e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8adb742373527d0dc3c1255357a863e5">load</a> ()</td></tr>
<tr class="memdesc:a8adb742373527d0dc3c1255357a863e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the metadata for the file system.  <br /></td></tr>
<tr class="separator:a8adb742373527d0dc3c1255357a863e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c23ebb59d7200219b31594ebcf7bbc" id="r_a60c23ebb59d7200219b31594ebcf7bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60c23ebb59d7200219b31594ebcf7bbc">format</a> ()</td></tr>
<tr class="memdesc:a60c23ebb59d7200219b31594ebcf7bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats the file system.  <br /></td></tr>
<tr class="separator:a60c23ebb59d7200219b31594ebcf7bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235738da1046644f12df4b002ea9e10b" id="r_a235738da1046644f12df4b002ea9e10b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a235738da1046644f12df4b002ea9e10b">fsck</a> (bool repair)</td></tr>
<tr class="memdesc:a235738da1046644f12df4b002ea9e10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a file system check. Not currently implemented!  <br /></td></tr>
<tr class="separator:a235738da1046644f12df4b002ea9e10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab15276d9b4c507fea822cdada1e509" id="r_a5ab15276d9b4c507fea822cdada1e509"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ab15276d9b4c507fea822cdada1e509">readData</a> (<a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_read_info.html">ReadInfo</a> &amp;readInfo)</td></tr>
<tr class="memdesc:a5ab15276d9b4c507fea822cdada1e509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next unread data from the circular buffer.  <br /></td></tr>
<tr class="separator:a5ab15276d9b4c507fea822cdada1e509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170c22ff2b87535bde6fe70ace81734c" id="r_a170c22ff2b87535bde6fe70ace81734c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a170c22ff2b87535bde6fe70ace81734c">markAsRead</a> (const <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_read_info.html">ReadInfo</a> &amp;readInfo)</td></tr>
<tr class="memdesc:a170c22ff2b87535bde6fe70ace81734c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the data from readData as read.  <br /></td></tr>
<tr class="separator:a170c22ff2b87535bde6fe70ace81734c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7c67e2849a53a5668f91b1f1770816" id="r_a2b7c67e2849a53a5668f91b1f1770816"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b7c67e2849a53a5668f91b1f1770816">writeData</a> (const <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_data_buffer.html">DataBuffer</a> &amp;data)</td></tr>
<tr class="memdesc:a2b7c67e2849a53a5668f91b1f1770816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the circular buffer.  <br /></td></tr>
<tr class="separator:a2b7c67e2849a53a5668f91b1f1770816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bc4080818916c9912b94740a2c69ce" id="r_a61bc4080818916c9912b94740a2c69ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61bc4080818916c9912b94740a2c69ce">getUsageStats</a> (<a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_usage_stats.html">UsageStats</a> &amp;usageStats)</td></tr>
<tr class="memdesc:a61bc4080818916c9912b94740a2c69ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the usage statistics.  <br /></td></tr>
<tr class="separator:a61bc4080818916c9912b94740a2c69ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b4dbe91cbf34d52edf4bd764bbe60e" id="r_a58b4dbe91cbf34d52edf4bd764bbe60e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58b4dbe91cbf34d52edf4bd764bbe60e">lock</a> ()</td></tr>
<tr class="memdesc:a58b4dbe91cbf34d52edf4bd764bbe60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex that protects shared resources.  <br /></td></tr>
<tr class="separator:a58b4dbe91cbf34d52edf4bd764bbe60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b3df3d2620ff85ea450da20f011f31" id="r_a89b3df3d2620ff85ea450da20f011f31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89b3df3d2620ff85ea450da20f011f31">tryLock</a> ()</td></tr>
<tr class="memdesc:a89b3df3d2620ff85ea450da20f011f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to lock the mutex that protects shared resources.  <br /></td></tr>
<tr class="separator:a89b3df3d2620ff85ea450da20f011f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c80016a21140072a0cab6eca6506bd3" id="r_a1c80016a21140072a0cab6eca6506bd3"><td class="memItemLeft" align="right" valign="top"><a id="a1c80016a21140072a0cab6eca6506bd3" name="a1c80016a21140072a0cab6eca6506bd3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock</b> ()</td></tr>
<tr class="memdesc:a1c80016a21140072a0cab6eca6506bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the mutex that protects shared resources. <br /></td></tr>
<tr class="separator:a1c80016a21140072a0cab6eca6506bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:afbb732c8d56c3f3b32227a18695e1e49" id="r_afbb732c8d56c3f3b32227a18695e1e49"><td class="memItemLeft" align="right" valign="top"><a id="afbb732c8d56c3f3b32227a18695e1e49" name="afbb732c8d56c3f3b32227a18695e1e49"></a>
class <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">CircularBufferSpiFlashRK::Sector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b></td></tr>
<tr class="separator:afbb732c8d56c3f3b32227a18695e1e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a481d4144f760d2bd516c181e4d285251" id="r_a481d4144f760d2bd516c181e4d285251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a481d4144f760d2bd516c181e4d285251">getSectorFromCache</a> (uint16_t sectorNum)</td></tr>
<tr class="memdesc:a481d4144f760d2bd516c181e4d285251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> object for a sector if it exists in the cache.  <br /></td></tr>
<tr class="separator:a481d4144f760d2bd516c181e4d285251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568538abd568f66774eb61a043e7d7d0" id="r_a568538abd568f66774eb61a043e7d7d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a568538abd568f66774eb61a043e7d7d0">getSector</a> (uint16_t sectorNum)</td></tr>
<tr class="memdesc:a568538abd568f66774eb61a043e7d7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> object for a sector, allocating and reading it if not in the cache.  <br /></td></tr>
<tr class="separator:a568538abd568f66774eb61a043e7d7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478099fd1c72c70e454e5d1f7e42e049" id="r_a478099fd1c72c70e454e5d1f7e42e049"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a478099fd1c72c70e454e5d1f7e42e049">readSector</a> (uint16_t sectorNum, <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *sector)</td></tr>
<tr class="memdesc:a478099fd1c72c70e454e5d1f7e42e049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to read the data from SPI flash. Use <a class="el" href="#a568538abd568f66774eb61a043e7d7d0" title="Get the Sector object for a sector, allocating and reading it if not in the cache.">getSector()</a> instead!  <br /></td></tr>
<tr class="separator:a478099fd1c72c70e454e5d1f7e42e049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6acce5c09acca8c9aa0e292f46059e0" id="r_aa6acce5c09acca8c9aa0e292f46059e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6acce5c09acca8c9aa0e292f46059e0">writeSectorHeader</a> (uint16_t sectorNum, bool erase, uint32_t sequence)</td></tr>
<tr class="memdesc:aa6acce5c09acca8c9aa0e292f46059e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to write a sector header. Use <a class="el" href="#a2b7c67e2849a53a5668f91b1f1770816" title="Write data to the circular buffer.">writeData()</a> instead!  <br /></td></tr>
<tr class="separator:aa6acce5c09acca8c9aa0e292f46059e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a5dd4d8b3788e4303b352526654199" id="r_aa3a5dd4d8b3788e4303b352526654199"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3a5dd4d8b3788e4303b352526654199">appendDataToSector</a> (<a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *sector, const <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_data_buffer.html">DataBuffer</a> &amp;data, uint16_t flags)</td></tr>
<tr class="memdesc:aa3a5dd4d8b3788e4303b352526654199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to append data to an existing sector. Use <a class="el" href="#a2b7c67e2849a53a5668f91b1f1770816" title="Write data to the circular buffer.">writeData()</a> instead!  <br /></td></tr>
<tr class="separator:aa3a5dd4d8b3788e4303b352526654199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3817217adba2e490573ecb55f5c66875" id="r_a3817217adba2e490573ecb55f5c66875"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3817217adba2e490573ecb55f5c66875">finalizeSector</a> (<a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *sector)</td></tr>
<tr class="memdesc:a3817217adba2e490573ecb55f5c66875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally when a sector is full and a new sector needs to be used. Use <a class="el" href="#a2b7c67e2849a53a5668f91b1f1770816" title="Write data to the circular buffer.">writeData()</a> instead!  <br /></td></tr>
<tr class="separator:a3817217adba2e490573ecb55f5c66875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86006434a834c159e32a23d15a1ee39b" id="r_a86006434a834c159e32a23d15a1ee39b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86006434a834c159e32a23d15a1ee39b">readDataFromSector</a> (<a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *sector, size_t index, <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_data_buffer.html">DataBuffer</a> &amp;data, <a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_record_common.html">RecordCommon</a> &amp;meta)</td></tr>
<tr class="memdesc:a86006434a834c159e32a23d15a1ee39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to read a record from a sector. Use <a class="el" href="#a5ab15276d9b4c507fea822cdada1e509" title="Read the next unread data from the circular buffer.">readData()</a> instead!  <br /></td></tr>
<tr class="separator:a86006434a834c159e32a23d15a1ee39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fcf83ed6b62ce020d765e55ab4b8fe" id="r_a19fcf83ed6b62ce020d765e55ab4b8fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19fcf83ed6b62ce020d765e55ab4b8fe">validateSector</a> (<a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *pSector)</td></tr>
<tr class="memdesc:a19fcf83ed6b62ce020d765e55ab4b8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to validate as sector. Only used for off-device unit tests.  <br /></td></tr>
<tr class="separator:a19fcf83ed6b62ce020d765e55ab4b8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37099570a9af48568d710c66977a3312" id="r_a37099570a9af48568d710c66977a3312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37099570a9af48568d710c66977a3312">sequenceToSectorNum</a> (uint32_t sequence, uint16_t &amp;sectorNum) const</td></tr>
<tr class="memdesc:a37099570a9af48568d710c66977a3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to find a sector number for a sequence number.  <br /></td></tr>
<tr class="separator:a37099570a9af48568d710c66977a3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a40e8e4d190ef859d04377c5bc5e83a" id="r_a4a40e8e4d190ef859d04377c5bc5e83a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a40e8e4d190ef859d04377c5bc5e83a">sectorNumToAddr</a> (uint16_t sectorNum) const</td></tr>
<tr class="memdesc:a4a40e8e4d190ef859d04377c5bc5e83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a sector number to an address.  <br /></td></tr>
<tr class="separator:a4a40e8e4d190ef859d04377c5bc5e83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed362f2b86c41054437890134242d339" id="r_aed362f2b86c41054437890134242d339"><td class="memItemLeft" align="right" valign="top"><a id="aed362f2b86c41054437890134242d339" name="aed362f2b86c41054437890134242d339"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearCache</b> ()</td></tr>
<tr class="memdesc:aed362f2b86c41054437890134242d339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove entries from the sector cache. <br /></td></tr>
<tr class="separator:aed362f2b86c41054437890134242d339"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a578b17b5feeb99c1ba0378e8726089b0" id="r_a578b17b5feeb99c1ba0378e8726089b0"><td class="memItemLeft" align="right" valign="top"><a id="a578b17b5feeb99c1ba0378e8726089b0" name="a578b17b5feeb99c1ba0378e8726089b0"></a>
SpiFlash *&#160;</td><td class="memItemRight" valign="bottom"><b>spiFlash</b></td></tr>
<tr class="memdesc:a578b17b5feeb99c1ba0378e8726089b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class to access the SPI flash chip. <br /></td></tr>
<tr class="separator:a578b17b5feeb99c1ba0378e8726089b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e0d4304539dc46c9ae8cc111a32388" id="r_a09e0d4304539dc46c9ae8cc111a32388"><td class="memItemLeft" align="right" valign="top"><a id="a09e0d4304539dc46c9ae8cc111a32388" name="a09e0d4304539dc46c9ae8cc111a32388"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>addrStart</b></td></tr>
<tr class="memdesc:a09e0d4304539dc46c9ae8cc111a32388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address in SPI flash where circular buffer begins, must be sector aligned. <br /></td></tr>
<tr class="separator:a09e0d4304539dc46c9ae8cc111a32388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf699ab2202f8c1b93f3a806e6f6bd2a" id="r_abf699ab2202f8c1b93f3a806e6f6bd2a"><td class="memItemLeft" align="right" valign="top"><a id="abf699ab2202f8c1b93f3a806e6f6bd2a" name="abf699ab2202f8c1b93f3a806e6f6bd2a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>addrEnd</b></td></tr>
<tr class="memdesc:abf699ab2202f8c1b93f3a806e6f6bd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address in SPI flash where circular buffer ends, must be sector aligned. <br /></td></tr>
<tr class="separator:abf699ab2202f8c1b93f3a806e6f6bd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ac0a6ad9a306eebd662ca45bc5c952" id="r_a53ac0a6ad9a306eebd662ca45bc5c952"><td class="memItemLeft" align="right" valign="top"><a id="a53ac0a6ad9a306eebd662ca45bc5c952" name="a53ac0a6ad9a306eebd662ca45bc5c952"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>sectorCount</b></td></tr>
<tr class="memdesc:a53ac0a6ad9a306eebd662ca45bc5c952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated in constructor, number of sectors from addrStart to addrEnd. <br /></td></tr>
<tr class="separator:a53ac0a6ad9a306eebd662ca45bc5c952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfb6fc1c16ecb3747ec582c63eff9d3" id="r_a6dfb6fc1c16ecb3747ec582c63eff9d3"><td class="memItemLeft" align="right" valign="top"><a id="a6dfb6fc1c16ecb3747ec582c63eff9d3" name="a6dfb6fc1c16ecb3747ec582c63eff9d3"></a>
<a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_sector_common.html">SectorCommon</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sectorMeta</b> = nullptr</td></tr>
<tr class="memdesc:a6dfb6fc1c16ecb3747ec582c63eff9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of <a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_sector_common.html" title="Data stored after the magic bytes in flash.">SectorCommon</a> structures, one for each sector. <br /></td></tr>
<tr class="separator:a6dfb6fc1c16ecb3747ec582c63eff9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71129a8c1f99f04194c48cac564a02f2" id="r_a71129a8c1f99f04194c48cac564a02f2"><td class="memItemLeft" align="right" valign="top"><a id="a71129a8c1f99f04194c48cac564a02f2" name="a71129a8c1f99f04194c48cac564a02f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValid</b> = false</td></tr>
<tr class="memdesc:a71129a8c1f99f04194c48cac564a02f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">true once <a class="el" href="#a8adb742373527d0dc3c1255357a863e5" title="Load the metadata for the file system.">load()</a> or <a class="el" href="#a60c23ebb59d7200219b31594ebcf7bbc" title="Formats the file system.">format()</a> has been called and is successful <br /></td></tr>
<tr class="separator:a71129a8c1f99f04194c48cac564a02f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062364dffc6f299317bbb093519050ed" id="r_a062364dffc6f299317bbb093519050ed"><td class="memItemLeft" align="right" valign="top"><a id="a062364dffc6f299317bbb093519050ed" name="a062364dffc6f299317bbb093519050ed"></a>
std::deque&lt; <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sectorCache</b></td></tr>
<tr class="memdesc:a062364dffc6f299317bbb093519050ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache used by <a class="el" href="#a568538abd568f66774eb61a043e7d7d0" title="Get the Sector object for a sector, allocating and reading it if not in the cache.">getSector()</a> <br /></td></tr>
<tr class="separator:a062364dffc6f299317bbb093519050ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80549fd6874d1b54b702625a6238de1" id="r_af80549fd6874d1b54b702625a6238de1"><td class="memItemLeft" align="right" valign="top"><a id="af80549fd6874d1b54b702625a6238de1" name="af80549fd6874d1b54b702625a6238de1"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>firstSequence</b> = 0</td></tr>
<tr class="memdesc:af80549fd6874d1b54b702625a6238de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence number of read from. <br /></td></tr>
<tr class="separator:af80549fd6874d1b54b702625a6238de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986083e8e9d153e217bb3cf882bd50d6" id="r_a986083e8e9d153e217bb3cf882bd50d6"><td class="memItemLeft" align="right" valign="top"><a id="a986083e8e9d153e217bb3cf882bd50d6" name="a986083e8e9d153e217bb3cf882bd50d6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>writeSequence</b> = 0</td></tr>
<tr class="memdesc:a986083e8e9d153e217bb3cf882bd50d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence number to write to. <br /></td></tr>
<tr class="separator:a986083e8e9d153e217bb3cf882bd50d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cb6344b834a5f9fbf3fa2b7ba1600c" id="r_ab0cb6344b834a5f9fbf3fa2b7ba1600c"><td class="memItemLeft" align="right" valign="top"><a id="ab0cb6344b834a5f9fbf3fa2b7ba1600c" name="ab0cb6344b834a5f9fbf3fa2b7ba1600c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>lastSequence</b> = 0</td></tr>
<tr class="memdesc:ab0cb6344b834a5f9fbf3fa2b7ba1600c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last sequence number used. <br /></td></tr>
<tr class="separator:ab0cb6344b834a5f9fbf3fa2b7ba1600c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8904f39e18d5a6782ddae2beb4173607" id="r_a8904f39e18d5a6782ddae2beb4173607"><td class="memItemLeft" align="right" valign="top">os_mutex_recursive_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8904f39e18d5a6782ddae2beb4173607">mutex</a> = 0</td></tr>
<tr class="memdesc:a8904f39e18d5a6782ddae2beb4173607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect shared resources.  <br /></td></tr>
<tr class="separator:a8904f39e18d5a6782ddae2beb4173607"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ad17c2ee2a4b2cbf4d2bfa9ab024bddaa" id="r_ad17c2ee2a4b2cbf4d2bfa9ab024bddaa"><td class="memItemLeft" align="right" valign="top"><a id="ad17c2ee2a4b2cbf4d2bfa9ab024bddaa" name="ad17c2ee2a4b2cbf4d2bfa9ab024bddaa"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>SECTOR_MAGIC</b> = 0x0ceb6443</td></tr>
<tr class="memdesc:ad17c2ee2a4b2cbf4d2bfa9ab024bddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic bytes stored at beginning of <a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_sector_header.html" title="Structure store at the beginning of each sector.">SectorHeader</a> structure. <br /></td></tr>
<tr class="separator:ad17c2ee2a4b2cbf4d2bfa9ab024bddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d27b412e85cc35b367fe2cade1b299" id="r_a70d27b412e85cc35b367fe2cade1b299"><td class="memItemLeft" align="right" valign="top"><a id="a70d27b412e85cc35b367fe2cade1b299" name="a70d27b412e85cc35b367fe2cade1b299"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>SECTOR_MAGIC_ERASED</b> = 0xffffffff</td></tr>
<tr class="memdesc:a70d27b412e85cc35b367fe2cade1b299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic bytes value if the sector is erased and not formatted. <br /></td></tr>
<tr class="separator:a70d27b412e85cc35b367fe2cade1b299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6572d4ee56457e6afd87f76bd25a832" id="r_aa6572d4ee56457e6afd87f76bd25a832"><td class="memItemLeft" align="right" valign="top"><a id="aa6572d4ee56457e6afd87f76bd25a832" name="aa6572d4ee56457e6afd87f76bd25a832"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>SECTOR_FLAG_STARTED_MASK</b> = 0x01</td></tr>
<tr class="memdesc:aa6572d4ee56457e6afd87f76bd25a832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit that is cleared when a sector is first written to after formatting. <br /></td></tr>
<tr class="separator:aa6572d4ee56457e6afd87f76bd25a832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac4189de4e4b04d63815188a139cc5e" id="r_a6ac4189de4e4b04d63815188a139cc5e"><td class="memItemLeft" align="right" valign="top"><a id="a6ac4189de4e4b04d63815188a139cc5e" name="a6ac4189de4e4b04d63815188a139cc5e"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>SECTOR_FLAG_FINALIZED_MASK</b> = 0x02</td></tr>
<tr class="memdesc:a6ac4189de4e4b04d63815188a139cc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit that is cleared when a sector has been fully written to. <br /></td></tr>
<tr class="separator:a6ac4189de4e4b04d63815188a139cc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5912ad454fc0c21838f6ff3cfc7b11eb" id="r_a5912ad454fc0c21838f6ff3cfc7b11eb"><td class="memItemLeft" align="right" valign="top"><a id="a5912ad454fc0c21838f6ff3cfc7b11eb" name="a5912ad454fc0c21838f6ff3cfc7b11eb"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>SECTOR_FLAG_CORRUPTED_MASK</b> = 0x04</td></tr>
<tr class="memdesc:a5912ad454fc0c21838f6ff3cfc7b11eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit that is cleared when a sector has invalid record structures. <br /></td></tr>
<tr class="separator:a5912ad454fc0c21838f6ff3cfc7b11eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e43d7fa6438a628d3fdba6c31bc503" id="r_a16e43d7fa6438a628d3fdba6c31bc503"><td class="memItemLeft" align="right" valign="top"><a id="a16e43d7fa6438a628d3fdba6c31bc503" name="a16e43d7fa6438a628d3fdba6c31bc503"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>RECORD_SIZE_ERASED</b> = 0xfff</td></tr>
<tr class="memdesc:a16e43d7fa6438a628d3fdba6c31bc503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record size value when there is no record at this location. This is the value of the 12-bit value when the sector is erased. <br /></td></tr>
<tr class="separator:a16e43d7fa6438a628d3fdba6c31bc503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82930c5b6f874f67ce420c988e9f52be" id="r_a82930c5b6f874f67ce420c988e9f52be"><td class="memItemLeft" align="right" valign="top"><a id="a82930c5b6f874f67ce420c988e9f52be" name="a82930c5b6f874f67ce420c988e9f52be"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>RECORD_FLAG_READ_MASK</b> = 0x1</td></tr>
<tr class="memdesc:a82930c5b6f874f67ce420c988e9f52be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit that is cleared when a record has been read. <br /></td></tr>
<tr class="separator:a82930c5b6f874f67ce420c988e9f52be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f99a80a69cdb6e1fb59891fe962dd7" id="r_ac6f99a80a69cdb6e1fb59891fe962dd7"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6f99a80a69cdb6e1fb59891fe962dd7">SECTOR_CACHE_SIZE</a> = 8</td></tr>
<tr class="memdesc:ac6f99a80a69cdb6e1fb59891fe962dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cached <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> structures used by getSector.  <br /></td></tr>
<tr class="separator:ac6f99a80a69cdb6e1fb59891fe962dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af8247a646cef67d55a0b61b5dd6533ae" name="af8247a646cef67d55a0b61b5dd6533ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8247a646cef67d55a0b61b5dd6533ae">&#9670;&#160;</a></span>CircularBufferSpiFlashRK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CircularBufferSpiFlashRK::CircularBufferSpiFlashRK </td>
          <td>(</td>
          <td class="paramtype">SpiFlash *</td>          <td class="paramname"><span class="paramname"><em>spiFlash</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>addrStart</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>addrEnd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new circular buffer object. This is typically done as a global variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spiFlash</td><td>The SpiFlashRK object for the SPI NOR flash chip. </td></tr>
    <tr><td class="paramname">addrStart</td><td>Address to start at (typically 0). Must be sector aligned (multiple of 4096 bytes). </td></tr>
    <tr><td class="paramname">addrEnd</td><td>Address to end at (not inclusive). Must be sector aligned (multiple of 4096 bytes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3a5dd4d8b3788e4303b352526654199" name="aa3a5dd4d8b3788e4303b352526654199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a5dd4d8b3788e4303b352526654199">&#9670;&#160;</a></span>appendDataToSector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::appendDataToSector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *</td>          <td class="paramname"><span class="paramname"><em>sector</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_data_buffer.html">DataBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to append data to an existing sector. Use <a class="el" href="#a2b7c67e2849a53a5668f91b1f1770816" title="Write data to the circular buffer.">writeData()</a> instead! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">flags</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure </dd></dl>

</div>
</div>
<a id="a3817217adba2e490573ecb55f5c66875" name="a3817217adba2e490573ecb55f5c66875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3817217adba2e490573ecb55f5c66875">&#9670;&#160;</a></span>finalizeSector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::finalizeSector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *</td>          <td class="paramname"><span class="paramname"><em>sector</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally when a sector is full and a new sector needs to be used. Use <a class="el" href="#a2b7c67e2849a53a5668f91b1f1770816" title="Write data to the circular buffer.">writeData()</a> instead! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure </dd></dl>

</div>
</div>
<a id="a60c23ebb59d7200219b31594ebcf7bbc" name="a60c23ebb59d7200219b31594ebcf7bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c23ebb59d7200219b31594ebcf7bbc">&#9670;&#160;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::format </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats the file system. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure</dd></dl>
<p>This will erase every sector and write an empty file structure to it. This must be done if the file system is invalid or erased. </p>

</div>
</div>
<a id="a235738da1046644f12df4b002ea9e10b" name="a235738da1046644f12df4b002ea9e10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235738da1046644f12df4b002ea9e10b">&#9670;&#160;</a></span>fsck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::fsck </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>repair</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a file system check. Not currently implemented! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">repair</td><td>True to attempt to repair a damaged circular buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure </dd></dl>

</div>
</div>
<a id="a568538abd568f66774eb61a043e7d7d0" name="a568538abd568f66774eb61a043e7d7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568538abd568f66774eb61a043e7d7d0">&#9670;&#160;</a></span>getSector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">CircularBufferSpiFlashRK::Sector</a> * CircularBufferSpiFlashRK::getSector </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>sectorNum</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> object for a sector, allocating and reading it if not in the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorNum</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sector*</dd></dl>
<p>The <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> object is just the metadata and an index of the records in it. It does not contain a copy of the data, so it's relatively small.</p>
<p>Do not delete the object returned by this method; it's owned by the cache and is not a copy! </p>

</div>
</div>
<a id="a481d4144f760d2bd516c181e4d285251" name="a481d4144f760d2bd516c181e4d285251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481d4144f760d2bd516c181e4d285251">&#9670;&#160;</a></span>getSectorFromCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">CircularBufferSpiFlashRK::Sector</a> * CircularBufferSpiFlashRK::getSectorFromCache </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>sectorNum</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> object for a sector if it exists in the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorNum</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sector* Object if it exists, or nullptr if not</dd></dl>
<p>The <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> object is just the metadata and an index of the records in it. It does not contain a copy of the data, so it's relatively small.</p>
<p>Do not delete the object returned by this method; it's owned by the cache and is not a copy! </p>

</div>
</div>
<a id="a61bc4080818916c9912b94740a2c69ce" name="a61bc4080818916c9912b94740a2c69ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61bc4080818916c9912b94740a2c69ce">&#9670;&#160;</a></span>getUsageStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::getUsageStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_usage_stats.html">UsageStats</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>usageStats</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the usage statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usageStats</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure</dd></dl>
<p>This method isn't const because it needs to obtain a lock on this object. </p>

</div>
</div>
<a id="a8adb742373527d0dc3c1255357a863e5" name="a8adb742373527d0dc3c1255357a863e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adb742373527d0dc3c1255357a863e5">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::load </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the metadata for the file system. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure</dd></dl>
<p>You must do this (or format) before using the file system. If this function returns false the format is not valid and you should format it. </p>

</div>
</div>
<a id="a58b4dbe91cbf34d52edf4bd764bbe60e" name="a58b4dbe91cbf34d52edf4bd764bbe60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b4dbe91cbf34d52edf4bd764bbe60e">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CircularBufferSpiFlashRK::lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the mutex that protects shared resources. </p>
<p>This is compatible with <code>WITH_LOCK(*this)</code>.</p>
<p>The mutex is not recursive so do not lock it within a locked section. </p>

</div>
</div>
<a id="a170c22ff2b87535bde6fe70ace81734c" name="a170c22ff2b87535bde6fe70ace81734c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170c22ff2b87535bde6fe70ace81734c">&#9670;&#160;</a></span>markAsRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::markAsRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_read_info.html">ReadInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>readInfo</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the data from readData as read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readInfo</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure</dd></dl>
<p>This method works properly even if the sector was overwritten because the buffer was full and additional data was written to it. It will ignore the mark as read in this case, because the data no longer exists. </p>

</div>
</div>
<a id="a5ab15276d9b4c507fea822cdada1e509" name="a5ab15276d9b4c507fea822cdada1e509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab15276d9b4c507fea822cdada1e509">&#9670;&#160;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_read_info.html">ReadInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>readInfo</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next unread data from the circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readInfo</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure</dd></dl>
<p>After reading the data, you must pass the same readInfo to markAsRead otherwise you'll read the same data again. </p>

</div>
</div>
<a id="a86006434a834c159e32a23d15a1ee39b" name="a86006434a834c159e32a23d15a1ee39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86006434a834c159e32a23d15a1ee39b">&#9670;&#160;</a></span>readDataFromSector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::readDataFromSector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *</td>          <td class="paramname"><span class="paramname"><em>sector</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_data_buffer.html">DataBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_record_common.html">RecordCommon</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>meta</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to read a record from a sector. Use <a class="el" href="#a5ab15276d9b4c507fea822cdada1e509" title="Read the next unread data from the circular buffer.">readData()</a> instead! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector</td><td></td></tr>
    <tr><td class="paramname">index</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">meta</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure </dd></dl>

</div>
</div>
<a id="a478099fd1c72c70e454e5d1f7e42e049" name="a478099fd1c72c70e454e5d1f7e42e049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478099fd1c72c70e454e5d1f7e42e049">&#9670;&#160;</a></span>readSector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::readSector </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>sectorNum</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *</td>          <td class="paramname"><span class="paramname"><em>sector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to read the data from SPI flash. Use <a class="el" href="#a568538abd568f66774eb61a043e7d7d0" title="Get the Sector object for a sector, allocating and reading it if not in the cache.">getSector()</a> instead! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorNum</td><td></td></tr>
    <tr><td class="paramname">sector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure </dd></dl>

</div>
</div>
<a id="a4a40e8e4d190ef859d04377c5bc5e83a" name="a4a40e8e4d190ef859d04377c5bc5e83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a40e8e4d190ef859d04377c5bc5e83a">&#9670;&#160;</a></span>sectorNumToAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CircularBufferSpiFlashRK::sectorNumToAddr </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>sectorNum</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a sector number to an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorNum</td><td>0 is the first sector of this buffer, not the device! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The byte address in in the device for the beginning of this sector </dd></dl>

</div>
</div>
<a id="a37099570a9af48568d710c66977a3312" name="a37099570a9af48568d710c66977a3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37099570a9af48568d710c66977a3312">&#9670;&#160;</a></span>sequenceToSectorNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::sequenceToSectorNum </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>sequence</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;</td>          <td class="paramname"><span class="paramname"><em>sectorNum</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to find a sector number for a sequence number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td></td></tr>
    <tr><td class="paramname">sectorNum</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure </dd></dl>

</div>
</div>
<a id="a89b3df3d2620ff85ea450da20f011f31" name="a89b3df3d2620ff85ea450da20f011f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b3df3d2620ff85ea450da20f011f31">&#9670;&#160;</a></span>tryLock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::tryLock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to lock the mutex that protects shared resources. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the mutex was locked or false if it was busy already. </dd></dl>

</div>
</div>
<a id="a19fcf83ed6b62ce020d765e55ab4b8fe" name="a19fcf83ed6b62ce020d765e55ab4b8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fcf83ed6b62ce020d765e55ab4b8fe">&#9670;&#160;</a></span>validateSector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::validateSector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html">Sector</a> *</td>          <td class="paramname"><span class="paramname"><em>pSector</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to validate as sector. Only used for off-device unit tests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure</dd></dl>
<p>This method validates all of the fields in the sector and assures that the data on flash matches the internal cache. It's only used during off-device unit tests, and will assert if the sector is not valid.</p>
<p>On-device it just always returns true. </p>

</div>
</div>
<a id="a2b7c67e2849a53a5668f91b1f1770816" name="a2b7c67e2849a53a5668f91b1f1770816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7c67e2849a53a5668f91b1f1770816">&#9670;&#160;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::writeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_data_buffer.html">DataBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to the circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure</dd></dl>
<p>Data is always written to the buffer. If the circular buffer is full, the oldest sector is deleted to make room for new data.</p>
<p>If there is a read in progress on the oldest sector, it will continue, however a markAsRead will be ignored since the underlying data will already have been deleted. </p>

</div>
</div>
<a id="aa6acce5c09acca8c9aa0e292f46059e0" name="aa6acce5c09acca8c9aa0e292f46059e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6acce5c09acca8c9aa0e292f46059e0">&#9670;&#160;</a></span>writeSectorHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CircularBufferSpiFlashRK::writeSectorHeader </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>sectorNum</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>erase</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>sequence</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to write a sector header. Use <a class="el" href="#a2b7c67e2849a53a5668f91b1f1770816" title="Write data to the circular buffer.">writeData()</a> instead! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorNum</td><td></td></tr>
    <tr><td class="paramname">erase</td><td></td></tr>
    <tr><td class="paramname">sequence</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on failure </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a8904f39e18d5a6782ddae2beb4173607" name="a8904f39e18d5a6782ddae2beb4173607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8904f39e18d5a6782ddae2beb4173607">&#9670;&#160;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">os_mutex_recursive_t CircularBufferSpiFlashRK::mutex = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex to protect shared resources. </p>
<p>This is initialized in setup() so make sure you call the setup() method from the global application setup. </p>

</div>
</div>
<a id="ac6f99a80a69cdb6e1fb59891fe962dd7" name="ac6f99a80a69cdb6e1fb59891fe962dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f99a80a69cdb6e1fb59891fe962dd7">&#9670;&#160;</a></span>SECTOR_CACHE_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t CircularBufferSpiFlashRK::SECTOR_CACHE_SIZE = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of cached <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> structures used by getSector. </p>
<p>The <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> structure does not contain the data, so this is not a lot of RAM, but can add up especially if you are storing small records because there's a vector of <a class="el" href="struct_circular_buffer_spi_flash_r_k_1_1_record_common.html" title="Data stored in flash for each record in the sector.">RecordCommon</a> structures, one for each record.</p>
<p>The cache exists because indexing a <a class="el" href="class_circular_buffer_spi_flash_r_k_1_1_sector.html" title="Information about a sector, stored in RAM.">Sector</a> requires n + 2 SPI reads where n is the number of records, so this can be a lot of transactions if you have small records. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_circular_buffer_spi_flash_r_k_8h_source.html">CircularBufferSpiFlashRK.h</a></li>
<li>src/<b>CircularBufferSpiFlashRK.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
